import { Op } from "sequelize";
import { sequelize } from "../config/db.js";   // üëà th√™m d√≤ng n√†y
import { DeNghiThanhToan_VuViec } from "../models/DeNghiThanhToan_VuViecModel.js";
import { DeNghiThanhToan } from "../models/DeNghiThanhToanModel.js";
import { VuViec } from "../models/vuViecModel.js";

export const addDeNghiThanhToan = async (req, res) => {
    const t = await sequelize.transaction();
    try {
        const {
            idDoiTac,
            idKhachHang,
            maHoSo,
            matterName,
            yourRef,
            contactInfo,
            maQuocGia,
            cases,
            subtotal,
            vat,
            total,
            maNhanSuCapNhap,
            deBitNoteNo,
            ngayGui,
            ngayThanhToan,
            ngayGuiHoaDon,
            ngayXuat,
            ghiChu,
        } = req.body;

        // auto gen s·ªë debit note
        // const deBitNoteNo = `DN-${Date.now()}`;

        // t·∫°o b·∫£n ghi ƒë·ªÅ ngh·ªã thanh to√°n
        const newRecord = await DeNghiThanhToan.create(
            {
                deBitNoteNo,
                maQuocGia: maQuocGia,
                idDoiTac,
                idKhachHang,
                maHoSo,
                yourRef,
                nguoiNhan: contactInfo?.nguoiLienHe,
                tenKhachHang: contactInfo?.ten,
                diaChiNguoiNhan: contactInfo?.diaChi,
                email: contactInfo?.email,
                thue: vat || 0,
                tongTien: subtotal || 0,
                tongTienSauThue: total || 0,
                loaiTienTe: "VND", // t·∫°m default, c√≥ th·ªÉ cho client truy·ªÅn v√†o
                isAutoImport: false,
                maNhanSuCapNhap,
                ngayGui,
                ngayThanhToan,
                ngayGuiHoaDon,
                ngayXuat,
                ghiChu,
            },
            { transaction: t }
        );

        // th√™m c√°c v·ª• vi·ªác v√†o b·∫£ng li√™n k·∫øt
        if (cases && cases.length > 0) {
            const caseLinks = cases.map((c) => ({
                idDeNghiThanhToan: newRecord.id,
                idVuViec: c.id,
                isAutoImport: false,
            }));
            await DeNghiThanhToan_VuViec.bulkCreate(caseLinks, { transaction: t });
        }

        await t.commit();

        return res.status(201).json({
            message: "T·∫°o ƒë·ªÅ ngh·ªã thanh to√°n th√†nh c√¥ng",
            data: newRecord,
        });
    } catch (error) {
        await t.rollback();
        console.error("‚ùå L·ªói khi t·∫°o ƒë·ªÅ ngh·ªã thanh to√°n:", error);
        return res.status(500).json({ message: "L·ªói server", error: error.message });
    }
};

export const getDeNghiThanhToansVN = async (req, res) => {
  try {
    const {
      fields = [],
      pageIndex = 1,
      pageSize = 20,
      idKhachHang,
      idDoiTac,
    } = req.body;

    const offset = (pageIndex - 1) * pageSize;

    // üîí C·ªë ƒë·ªãnh VN
    const whereCondition = { maQuocGia: "VN" };
    if (idDoiTac) whereCondition.idDoiTac = idDoiTac;
    if (idKhachHang) whereCondition.idKhachHang = idKhachHang;

    const totalItems = await DeNghiThanhToan.count({ where: whereCondition });

    const deNghiThanhToans = await DeNghiThanhToan.findAll({
      where: whereCondition,
      // include: [
      //   { model: DoiTac, as: "DoiTac", attributes: ["tenDoiTac"] },
      //   { model: QuocGia, as: "QuocGia", attributes: ["tenQuocGia"] },
      //   { model: KhachHangCuoi, as: "KhachHangCuoi", attributes: ["tenKhachHang"] },
      // ],
      limit: pageSize,
      offset,
      order: [["id", "DESC"]],
    });

    if (!deNghiThanhToans.length) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë·ªÅ ngh·ªã thanh to√°n (VN)" });
    }

    const fieldMap = {
      id: dn => dn.id,
      maHoSo: dn => dn.maHoSo,
      deBitNoteNo: dn => dn.deBitNoteNo,
      nguoiNhan: dn => dn.nguoiNhan,
      tenKhachHang: dn => dn.tenKhachHang,
      diaChiNguoiNhan: dn => dn.diaChiNguoiNhan,
      email: dn => dn.email,
      tongTien: dn => dn.tongTien,
      tongTienSauThue: dn => dn.tongTienSauThue,
      ngayGui: dn => dn.ngayGui,
      ngayThanhToan: dn => dn.ngayThanhToan,
      ngayGuiHoaDon: dn => dn.ngayGuiHoaDon,
      ngayXuat: dn => dn.ngayXuat,
      ghiChu: dn => dn.ghiChu,
    };

    const result = deNghiThanhToans.map(dn => {
      const row = { id: dn.id };
      fields.forEach(f => {
        if (fieldMap[f]) row[f] = fieldMap[f](dn);
      });
      row.loaiTienTe = dn.loaiTienTe; // lu√¥n ƒë·∫©y ra
      return row;
    });

    res.status(200).json({
      data: result,
      pagination: {
        totalItems,
        totalPages: Math.ceil(totalItems / pageSize),
        pageIndex: Number(pageIndex),
        pageSize: Number(pageSize),
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

export const getDeNghiThanhToansKH = async (req, res) => {
  try {
    const {
      fields = [],
      pageIndex = 1,
      pageSize = 20,
      idKhachHang,
      idDoiTac,
    } = req.body;

    const offset = (pageIndex - 1) * pageSize;

    // üîí C·ªë ƒë·ªãnh KH
    const whereCondition = { maQuocGia: "KH" };
    if (idDoiTac) whereCondition.idDoiTac = idDoiTac;
    if (idKhachHang) whereCondition.idKhachHang = idKhachHang;

    const totalItems = await DeNghiThanhToan.count({ where: whereCondition });

    const deNghiThanhToans = await DeNghiThanhToan.findAll({
      where: whereCondition,
      // include: [... nh∆∞ tr√™n n·∫øu c·∫ßn ...],
      limit: pageSize,
      offset,
      order: [["id", "DESC"]],
    });

    if (!deNghiThanhToans.length) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë·ªÅ ngh·ªã thanh to√°n (KH)" });
    }

    const fieldMap = {
      id: dn => dn.id,
      maHoSo: dn => dn.maHoSo,
      deBitNoteNo: dn => dn.deBitNoteNo,
      nguoiNhan: dn => dn.nguoiNhan,
      tenKhachHang: dn => dn.tenKhachHang,
      diaChiNguoiNhan: dn => dn.diaChiNguoiNhan,
      email: dn => dn.email,
      tongTien: dn => dn.tongTien,
      tongTienSauThue: dn => dn.tongTienSauThue,
      ngayGui: dn => dn.ngayGui,
      ngayThanhToan: dn => dn.ngayThanhToan,
      ngayGuiHoaDon: dn => dn.ngayGuiHoaDon,
      ngayXuat: dn => dn.ngayXuat,
      ghiChu: dn => dn.ghiChu,
    };

    const result = deNghiThanhToans.map(dn => {
      const row = { id: dn.id };
      fields.forEach(f => {
        if (fieldMap[f]) row[f] = fieldMap[f](dn);
      });
      row.loaiTienTe = dn.loaiTienTe;
      return row;
    });

    res.status(200).json({
      data: result,
      pagination: {
        totalItems,
        totalPages: Math.ceil(totalItems / pageSize),
        pageIndex: Number(pageIndex),
        pageSize: Number(pageSize),
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

export const getDeNghiThanhToanDetail = async (req, res) => {
    try {
        const { id } = req.body;

        if (!id) {
            return res.status(400).json({ message: "Thi·∫øu id ƒë·ªÅ ngh·ªã thanh to√°n" });
        }

        const deNghiThanhToan = await DeNghiThanhToan.findOne({
            where: { id },
            include: [
                {
                    model: DeNghiThanhToan_VuViec,
                    as: "DeNghiThanhToan_VuViec",
                    attributes: ["idVuViec", "isAutoImport"],
                    include: [
                        {
                            model: VuViec,
                            as: "VuViec", // ph·∫£i tr√πng alias khi define association
                            attributes: ["moTa", "tenVuViec", "soTien"],
                        },
                    ],
                },
            ],
        });


        if (!deNghiThanhToan) {
            return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë·ªÅ ngh·ªã thanh to√°n" });
        }

        return res.status(200).json({
            data: deNghiThanhToan,
        });
    } catch (error) {
        console.error("‚ùå L·ªói khi l·∫•y chi ti·∫øt ƒë·ªÅ ngh·ªã thanh to√°n:", error);
        return res.status(500).json({ message: "L·ªói server", error: error.message });
    }
};

export const editDeNghiThanhToan = async (req, res) => {
    const t = await sequelize.transaction();
    try {
        const {
            id,
            idDoiTac,
            idKhachHang,
            maHoSo,
            matterName,
            yourRef,
            contactInfo,
            cases,
            subtotal,
            vat,
            total,
            maNhanSuCapNhap,
            deBitNoteNo,
            ngayGui,
            ngayThanhToan,
            ngayGuiHoaDon,
            ngayXuat,
            ghiChu,
        } = req.body;

        if (!id) {
            return res.status(400).json({ message: "Thi·∫øu id ƒë·ªÅ ngh·ªã thanh to√°n" });
        }

        // T√¨m b·∫£n ghi c·∫ßn update
        const existingRecord = await DeNghiThanhToan.findOne({ where: { id } });
        if (!existingRecord) {
            return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë·ªÅ ngh·ªã thanh to√°n" });
        }

        // C·∫≠p nh·∫≠t d·ªØ li·ªáu
        await existingRecord.update(
            {
                deBitNoteNo: deBitNoteNo || existingRecord.deBitNoteNo,
                maQuocGia: contactInfo?.maQuocGia || existingRecord.maQuocGia,
                idDoiTac,
                idKhachHang,
                maHoSo,
                yourRef,
                nguoiNhan: contactInfo?.nguoiLienHe,
                tenKhachHang: contactInfo?.ten,
                diaChiNguoiNhan: contactInfo?.diaChi,
                email: contactInfo?.email,
                thue: vat ?? existingRecord.thue,
                tongTien: subtotal ?? existingRecord.tongTien,
                tongTienSauThue: total ?? existingRecord.tongTienSauThue,
                loaiTienTe: "VND", // v·∫´n default
                maNhanSuCapNhap,
                ngayGui,
                ngayThanhToan,
                ngayGuiHoaDon,
                ngayXuat,
                ghiChu,
            },
            { transaction: t }
        );

        // C·∫≠p nh·∫≠t l·∫°i danh s√°ch v·ª• vi·ªác
        if (cases && Array.isArray(cases)) {
            // X√≥a c√°c li√™n k·∫øt c≈©
            await DeNghiThanhToan_VuViec.destroy({
                where: { idDeNghiThanhToan: id },
                transaction: t,
            });

            // Th√™m li√™n k·∫øt m·ªõi
            if (cases.length > 0) {
                const caseLinks = cases.map((c) => ({
                    idDeNghiThanhToan: id,
                    idVuViec: c.id,
                    isAutoImport: false,
                }));
                await DeNghiThanhToan_VuViec.bulkCreate(caseLinks, { transaction: t });
            }
        }

        await t.commit();

        return res.status(200).json({
            message: "C·∫≠p nh·∫≠t ƒë·ªÅ ngh·ªã thanh to√°n th√†nh c√¥ng",
            data: existingRecord,
        });
    } catch (error) {
        await t.rollback();
        console.error("‚ùå L·ªói khi c·∫≠p nh·∫≠t ƒë·ªÅ ngh·ªã thanh to√°n:", error);
        return res.status(500).json({ message: "L·ªói server", error: error.message });
    }
};
